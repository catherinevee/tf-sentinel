# Policy: AWS Comprehensive Encryption Enforcement
# Purpose: Enforces encryption at rest and in transit for all AWS services with fail-secure defaults
# Scope: S3, RDS, EBS, EFS, Redshift, DynamoDB, SNS, SQS, Secrets Manager, KMS, Lambda
# Enforcement: hard-mandatory
#
# Validates:
# - S3 bucket server-side encryption with KMS
# - RDS/Aurora encryption at rest
# - EBS volume encryption
# - EFS encryption at rest and in transit
# - Redshift encryption
# - DynamoDB encryption at rest
# - SNS topic encryption
# - SQS queue encryption
# - Secrets Manager encryption
# - Lambda environment variable encryption
# - KMS key policies and rotation

import "tfplan/v2" as tfplan
import "tfstate/v2" as tfstate  
import "tfconfig/v2" as tfconfig
import "tfrun" as tfrun
import "strings"

# Parameters with secure defaults
param environment default "dev"
param allowed_kms_key_types default ["aws/s3", "aws/rds", "aws/ebs", "aws/efs", "aws/lambda"]
param require_customer_managed_keys default false
param enforce_key_rotation default true

# Comprehensive encryption validation with defense in depth
validate_encryption = func(resource) {
    # Input validation - fail secure on null/undefined
    if resource is null {
        print("SECURITY ERROR: Resource validation failed - null resource detected")
        return false
    }
    
    if resource.change is null {
        print("SECURITY ERROR: Resource change is null for:", resource.address else "unknown")
        return false
    }
    
    violations = []
    resource_type = resource.type else "unknown"
    resource_address = resource.address else "unknown"
    
    # Check for computed values - handle gracefully but securely
    if resource.change.after is computed {
        print("WARNING: Resource attributes are computed for", resource_address, "- applying conservative validation")
        return validate_with_computed_values(resource)
    }
    
    # S3 Bucket Encryption Validation
    if resource_type is "aws_s3_bucket" {
        violations = append(violations, validate_s3_encryption(resource)...)
    }
    
    # RDS/Aurora Encryption Validation
    if resource_type in ["aws_db_instance", "aws_rds_cluster"] {
        violations = append(violations, validate_rds_encryption(resource)...)
    }
    
    # EBS Volume Encryption Validation
    if resource_type is "aws_ebs_volume" {
        violations = append(violations, validate_ebs_encryption(resource)...)
    }
    
    # EFS Encryption Validation
    if resource_type is "aws_efs_file_system" {
        violations = append(violations, validate_efs_encryption(resource)...)
    }
    
    # Redshift Encryption Validation
    if resource_type is "aws_redshift_cluster" {
        violations = append(violations, validate_redshift_encryption(resource)...)
    }
    
    # DynamoDB Encryption Validation
    if resource_type is "aws_dynamodb_table" {
        violations = append(violations, validate_dynamodb_encryption(resource)...)
    }
    
    # SNS Topic Encryption Validation
    if resource_type is "aws_sns_topic" {
        violations = append(violations, validate_sns_encryption(resource)...)
    }
    
    # SQS Queue Encryption Validation
    if resource_type is "aws_sqs_queue" {
        violations = append(violations, validate_sqs_encryption(resource)...)
    }
    
    # Secrets Manager Encryption Validation
    if resource_type is "aws_secretsmanager_secret" {
        violations = append(violations, validate_secrets_manager_encryption(resource)...)
    }
    
    # Lambda Function Encryption Validation
    if resource_type is "aws_lambda_function" {
        violations = append(violations, validate_lambda_encryption(resource)...)
    }
    
    # KMS Key Validation
    if resource_type is "aws_kms_key" {
        violations = append(violations, validate_kms_key_policy(resource)...)
    }
    
    # Report violations with detailed context
    if length(violations) > 0 {
        print("ENCRYPTION POLICY VIOLATIONS found for", resource_address + ":")
        for violations as violation {
            print("  - VIOLATION:", violation)
        }
        return false
    }
    
    return true
}

# S3 Encryption Validation with comprehensive checks
validate_s3_encryption = func(resource) {
    violations = []
    resource_after = resource.change.after else {}
    
    # Check server-side encryption configuration
    sse_config = resource_after.server_side_encryption_configuration else []
    if length(sse_config) == 0 {
        append(violations, "S3 bucket must have server-side encryption enabled")
        return violations
    }
    
    # Validate encryption algorithm and KMS usage
    for sse_config as config {
        rules = config.rule else []
        if length(rules) == 0 {
            append(violations, "S3 bucket encryption configuration must include rules")
            continue
        }
        
        for rules as rule {
            apply_sse = rule.apply_server_side_encryption_by_default else {}
            sse_algorithm = apply_sse.sse_algorithm else ""
            
            if sse_algorithm not in ["AES256", "aws:kms"] {
                append(violations, "S3 bucket must use AES256 or aws:kms encryption")
            }
            
            # For production environments, require KMS
            if environment is "prod" and sse_algorithm is not "aws:kms" {
                append(violations, "Production S3 buckets must use KMS encryption")
            }
            
            # Validate KMS key if specified
            if sse_algorithm is "aws:kms" {
                kms_key_id = apply_sse.kms_master_key_id else ""
                if require_customer_managed_keys and strings.has_prefix(kms_key_id, "alias/aws/") {
                    append(violations, "S3 bucket must use customer-managed KMS key")
                }
            }
        }
    }
    
    # Check bucket key for cost optimization
    bucket_key_enabled = resource_after.bucket_key_enabled else false
    if environment is "prod" and not bucket_key_enabled {
        append(violations, "Production S3 buckets should enable bucket key for cost optimization")
    }
    
    return violations
}

# RDS Encryption Validation
validate_rds_encryption = func(resource) {
    violations = []
    resource_after = resource.change.after else {}
    
    storage_encrypted = resource_after.storage_encrypted else false
    if not storage_encrypted {
        append(violations, "RDS instance must have storage encryption enabled")
    }
    
    # Validate KMS key for customer-managed encryption
    if storage_encrypted and require_customer_managed_keys {
        kms_key_id = resource_after.kms_key_id else ""
        if length(kms_key_id) == 0 or strings.has_prefix(kms_key_id, "alias/aws/") {
            append(violations, "RDS instance must use customer-managed KMS key")
        }
    }
    
    # For RDS clusters, check additional settings
    if resource.type is "aws_rds_cluster" {
        # Check backup encryption
        backup_retention_period = resource_after.backup_retention_period else 0
        if backup_retention_period > 0 and not storage_encrypted {
            append(violations, "RDS cluster with backups must have encryption enabled")
        }
        
        # Check performance insights encryption
        performance_insights_enabled = resource_after.performance_insights_enabled else false
        if performance_insights_enabled {
            pi_kms_key_id = resource_after.performance_insights_kms_key_id else ""
            if length(pi_kms_key_id) == 0 {
                append(violations, "Performance Insights must use KMS encryption")
            }
        }
    }
    
    return violations
}

# EBS Volume Encryption Validation
validate_ebs_encryption = func(resource) {
    violations = []
    resource_after = resource.change.after else {}
    
    encrypted = resource_after.encrypted else false
    if not encrypted {
        append(violations, "EBS volume must be encrypted")
    }
    
    # Validate KMS key
    if encrypted and require_customer_managed_keys {
        kms_key_id = resource_after.kms_key_id else ""
        if length(kms_key_id) == 0 or strings.has_prefix(kms_key_id, "alias/aws/") {
            append(violations, "EBS volume must use customer-managed KMS key")
        }
    }
    
    return violations
}

# EFS Encryption Validation
validate_efs_encryption = func(resource) {
    violations = []
    resource_after = resource.change.after else {}
    
    # Check encryption at rest
    encrypted = resource_after.encrypted else false
    if not encrypted {
        append(violations, "EFS file system must have encryption at rest enabled")
    }
    
    # Validate KMS key
    if encrypted and require_customer_managed_keys {
        kms_key_id = resource_after.kms_key_id else ""
        if length(kms_key_id) == 0 or strings.has_prefix(kms_key_id, "alias/aws/") {
            append(violations, "EFS file system must use customer-managed KMS key")
        }
    }
    
    return violations
}

# Additional validation functions for other services
validate_redshift_encryption = func(resource) {
    violations = []
    resource_after = resource.change.after else {}
    
    encrypted = resource_after.encrypted else false
    if not encrypted {
        append(violations, "Redshift cluster must be encrypted")
    }
    
    return violations
}

validate_dynamodb_encryption = func(resource) {
    violations = []
    resource_after = resource.change.after else {}
    
    server_side_encryption = resource_after.server_side_encryption else []
    if length(server_side_encryption) == 0 {
        append(violations, "DynamoDB table must have server-side encryption enabled")
    }
    
    return violations
}

validate_sns_encryption = func(resource) {
    violations = []
    resource_after = resource.change.after else {}
    
    kms_master_key_id = resource_after.kms_master_key_id else ""
    if length(kms_master_key_id) == 0 {
        append(violations, "SNS topic must have KMS encryption enabled")
    }
    
    return violations
}

validate_sqs_encryption = func(resource) {
    violations = []
    resource_after = resource.change.after else {}
    
    kms_master_key_id = resource_after.kms_master_key_id else ""
    if length(kms_master_key_id) == 0 {
        append(violations, "SQS queue must have KMS encryption enabled")
    }
    
    return violations
}

validate_secrets_manager_encryption = func(resource) {
    violations = []
    resource_after = resource.change.after else {}
    
    kms_key_id = resource_after.kms_key_id else ""
    if length(kms_key_id) == 0 {
        append(violations, "Secrets Manager secret must specify KMS key")
    }
    
    return violations
}

validate_lambda_encryption = func(resource) {
    violations = []
    resource_after = resource.change.after else {}
    
    environment_config = resource_after.environment else []
    if length(environment_config) > 0 {
        for environment_config as env {
            kms_key_arn = env.kms_key_arn else ""
            variables = env.variables else {}
            if length(variables) > 0 and length(kms_key_arn) == 0 {
                append(violations, "Lambda function with environment variables must use KMS encryption")
            }
        }
    }
    
    return violations
}

validate_kms_key_policy = func(resource) {
    violations = []
    resource_after = resource.change.after else {}
    
    # Check key rotation if enabled
    if enforce_key_rotation {
        enable_key_rotation = resource_after.enable_key_rotation else false
        if not enable_key_rotation {
            append(violations, "KMS key must have automatic rotation enabled")
        }
    }
    
    # Check deletion window
    deletion_window = resource_after.deletion_window_in_days else 30
    if deletion_window < 7 {
        append(violations, "KMS key deletion window must be at least 7 days")
    }
    
    return violations
}

# Handle computed values securely
validate_with_computed_values = func(resource) {
    print("INFO: Applying conservative validation for computed resource:", resource.address else "unknown")
    
    # For computed resources, apply default security assumptions
    resource_type = resource.type else "unknown"
    
    # Only allow known secure resource types with computed values
    allowed_computed_types = [
        "aws_s3_bucket",
        "aws_db_instance", 
        "aws_rds_cluster",
        "aws_ebs_volume",
        "aws_efs_file_system"
    ]
    
    if resource_type not in allowed_computed_types {
        print("SECURITY WARNING: Computed resource type not in approved list:", resource_type)
        return false
    }
    
    return true
}

# Efficient resource filtering with early filtering
encryption_target_resources = filter tfplan.resource_changes as _, rc {
    rc.mode is "managed" and
    rc.type in [
        "aws_s3_bucket",
        "aws_db_instance", 
        "aws_rds_cluster",
        "aws_ebs_volume",
        "aws_efs_file_system",
        "aws_redshift_cluster",
        "aws_dynamodb_table",
        "aws_sns_topic",
        "aws_sqs_queue",
        "aws_secretsmanager_secret",
        "aws_lambda_function",
        "aws_kms_key"
    ] and
    rc.change.actions is not ["delete"]
}

# Main rule with comprehensive validation and fail-secure defaults
main = rule when length(encryption_target_resources) > 0 {
    all encryption_target_resources as _, resource {
        validate_encryption(resource)
    }
}
